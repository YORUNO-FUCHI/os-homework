os-lab4草稿

三个对象：IPC中的3个对 象：共享内存、信号灯数组、消息队列，来解决协作并发进程间的同步与互斥的问 题。 

键值的解释：

在操作系统中，**键值（Key）** 是用于唯一标识 **IPC对象**（如共享内存、信号量、消息队列）的整数值。通过键值，不同进程可以访问同一个IPC对象。键值的定义需要满足以下条件：

- **唯一性**：同一系统中，不同IPC对象的键值应不同，否则可能导致冲突。
- **一致性**：生产者和消费者需使用相同的键值访问同一IPC对象。

在本次实验的代码中  `producer.c` 中，键值直接硬编码为固定数值：



信号灯;

##### **(1) `prod_sem`（键值 `prod_key=201`）**

- **类型**：**同步信号灯**（计数信号量）。

- **物理意义**：表示 **缓冲区剩余空位数量**（生产者可写入的位置数）。

- **初始值**：`buff_num`（如8），表示初始缓冲区全空。

- 

  消费者操作

  ：

  - 

    `up(prod_sem)`

    ：消费者每消费一个数据后调用此操作，通知生产者缓冲区腾出一个空位。

    c

    复制

    ```
    up(prod_sem);  // 唤醒可能阻塞的生产者
    ```

**消费者视角的意义**：
消费者通过 `up(prod_sem)` 向生产者发送“有空位”的信号，使生产者能够继续写入数据。

------

##### **(2) `pmtx_sem`（键值 `pmtx_key=202`）**

- **类型**：**互斥信号灯**（二进制信号量）。

- **物理意义**：保护 **生产者写入缓冲区的互斥锁**。

- **初始值**：`1`，表示锁空闲。

- 

  消费者操作

  ：

  - **消费者不直接操作 `pmtx_sem`**：该信号灯仅用于生产者之间的互斥，消费者无需获取或释放。

**消费者视角的意义**：
消费者与 `pmtx_sem` 无关，它只影响生产者的写入操作。

------

##### **(3) `cons_sem`（键值 `cons_key=301`）**

- **类型**：**同步信号灯**（计数信号量）。

- **物理意义**：表示 **缓冲区已填充数据数量**（消费者可读取的数据数）。

- **初始值**：`0`，表示初始缓冲区无数据。

- 

  消费者操作

  ：

  - 

    `down(cons_sem)`

    ：消费者尝试读取数据前调用此操作，若值为0则阻塞等待。

    c

    复制

    ```
    down(cons_sem);  // 等待缓冲区有数据
    ```

**消费者视角的意义**：
消费者必须等待 `cons_sem` 值大于0（即生产者写入数据后调用 `up(cons_sem)`）才能开始读取。

------

##### **(4) `cmtx_sem`（键值 `cmtx_key=302`）**

- **类型**：**互斥信号灯**（二进制信号量）。

- **物理意义**：保护 **消费者读取缓冲区的互斥锁**。

- **初始值**：`1`，表示锁空闲。

- 

  消费者操作

  ：

  - **`down(cmtx_sem)`**：消费者读取数据前获取锁，防止其他消费者同时读取。

  - 

    `up(cmtx_sem)`

    ：读取完成后释放锁。

    c

    复制

    ```
    down(cmtx_sem);  // 加锁
    // 读取数据
    up(cmtx_sem);    // 解锁
    ```

**消费者视角的意义**：
确保同一时间只有一个消费者操作读指针 `cget_ptr`，避免多个消费者读取同一位置或更新指针时发生冲突。



问题：信号量什么意思 ？ 这里面的作用？

```c
int get_ipc_id(char *proc_file, key_t key) {
    FILE *pf = fopen(proc_file, "r");
    char line[BUFSZ], colum[BUFSZ];
    // 解析文件内容，匹配key对应的IPC对象ID
    while (!feof(pf)) {
        fgets(line, BUFSZ, pf);
        // 提取键值并匹配
        if (atoi(colum) == key) {
            // 返回对应的IPC对象ID
            return atoi(colum);
        }
    }
    return -1; // 未找到返回-1
}
```

这是在找什么内容？匹配的内容是什么

```c
// 创建或附加共享内存
char *set_shm(key_t shm_key, int shm_num, int shm_flag) {
    int shm_id;
    // 检查共享内存是否已存在
    if ((shm_id = get_ipc_id("/proc/sysvipc/shm", shm_key)) < 0) {
        // 不存在则新建
        shm_id = shmget(shm_key, shm_num, shm_flag);
        char *shm_buf = (char *)shmat(shm_id, 0, 0);
        // 初始化共享内存为全0
        for (int i = 0; i < shm_num; i++) shm_buf[i] = 0;
    } else {
        // 已存在则附加
        char *shm_buf = (char *)shmat(shm_id, 0, 0);
    }
    return shm_buf;
}

```

循环是干什么的

