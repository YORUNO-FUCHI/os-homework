# 页面置换算法模拟实验报告

## 1. 实验目的与内容

本实验通过编程实现了六种经典的页面置换算法：FIFO（先进先出）、LRU（最近最少使用）、Clock（时钟算法）、Enhanced Clock（增强二次机会算法）、LFU（最少使用频率）和MFU（最多使用频率）算法，通过模拟不同的页面引用串和内存帧数配置，分析各算法的性能特点。

## 2. 不同引用串与内存帧的测试现象

### 2.1 测试配置

在实验中，我们进行了以下几组典型测试：

**测试组1：循环引用串**

引用串：1 2 3 4 1 2 3 4 1 2 内存帧数：2, 3, 4, 5

我们以内存帧数为4的输出结果为例：

```bash
===== FIFO 算法 =====
1
1 2
1 2 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== LRU 算法 =====
1
2 1
3 2 1
4 3 2 1
1 4 3 2
2 1 4 3
3 2 1 4
4 3 2 1
1 4 3 2
2 1 4 3

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== Clock 算法 =====
1(1)  -> 0
1(1) 2(1)  -> 0
1(1) 2(1) 3(1)  -> 0
1(1) 2(1) 3(1) 4(1)  -> 0
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(10) 2(11)  -> (空闲帧)
1(10) 2(11) 3(10)  -> (空闲帧)
1(10) 2(11) 3(10) 4(11)  -> (空闲帧)
1(11) 2(11) 3(10) 4(11)
1(11) 2(11) 3(10) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 2(1)  -> (空闲帧)
1(1) 2(1) 3(1)  -> (空闲帧)
1(1) 2(1) 3(1) 4(1)  -> (空闲帧)
1(2) 2(1) 3(1) 4(1)
1(2) 2(2) 3(1) 4(1)
1(2) 2(2) 3(2) 4(1)
1(2) 2(2) 3(2) 4(2)
1(3) 2(2) 3(2) 4(2)
1(3) 2(3) 3(2) 4(2)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 2(1)  -> (空闲帧)
1(1) 2(1) 3(1)  -> (空闲帧)
1(1) 2(1) 3(1) 4(1)  -> (空闲帧)
1(2) 2(1) 3(1) 4(1)
1(2) 2(2) 3(1) 4(1)
1(2) 2(2) 3(2) 4(1)
1(2) 2(2) 3(2) 4(2)
1(3) 2(2) 3(2) 4(2)
1(3) 2(3) 3(2) 4(2)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%
```

**测试组2：随机引用串**

引用串：1r 4r 5r 6r 7w 1r 4r 6r 4r 6r 4r 6r 2r 5r 内存帧数：2, 3, 4, 5

我们以内存帧数为4的输出结果为例：

```bash
===== FIFO 算法 =====
1
1 4
1 4 5
1 4 5 6
7 4 5 6  -> 1
7 1 5 6  -> 4
7 1 4 6  -> 5
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 2  -> 6
5 1 4 2  -> 7

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 7
缺页次数 = 9
缺页率 = 64.29%

===== LRU 算法 =====
1
4 1
5 4 1
6 5 4 1
7 6 5 4  -> 1
1 7 6 5  -> 4
4 1 7 6  -> 5
6 4 1 7
4 6 1 7
6 4 1 7
4 6 1 7
6 4 1 7
2 6 4 1  -> 7
5 2 6 4  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 7 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== Clock 算法 =====
1(1)  -> 0
1(1) 4(1)  -> 0
1(1) 4(1) 5(1)  -> 0
1(1) 4(1) 5(1) 6(1)  -> 0
7(1) 4(0) 5(0) 6(0)  -> 1
7(1) 1(1) 5(0) 6(0)  -> 4
7(1) 1(1) 4(1) 6(0)  -> 5
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(0) 1(0) 4(0) 2(1)  -> 6
5(1) 1(0) 4(0) 2(1)  -> 7

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 7
缺页次数 = 9
缺页率 = 64.29%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(10) 4(10)  -> (空闲帧)
1(10) 4(10) 5(10)  -> (空闲帧)
1(10) 4(10) 5(10) 6(10)  -> (空闲帧)
7(11) 4(00) 5(00) 6(00)  -> 1
7(11) 1(10) 5(00) 6(00)  -> 4
7(11) 1(10) 4(10) 6(00)  -> 5
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(01) 1(00) 4(00) 2(10)  -> 6
7(01) 5(10) 4(00) 2(10)  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 4(1)  -> (空闲帧)
1(1) 4(1) 5(1)  -> (空闲帧)
1(1) 4(1) 5(1) 6(1)  -> (空闲帧)
7(1) 4(1) 5(1) 6(1)  -> 1
7(1) 1(1) 5(1) 6(1)  -> 4
7(1) 1(1) 4(1) 6(1)  -> 5
7(1) 1(1) 4(1) 6(2)
7(1) 1(1) 4(2) 6(2)
7(1) 1(1) 4(2) 6(3)
7(1) 1(1) 4(3) 6(3)
7(1) 1(1) 4(3) 6(4)
2(1) 1(1) 4(3) 6(4)  -> 7
2(1) 5(1) 4(3) 6(4)  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 7 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 4(1)  -> (空闲帧)
1(1) 4(1) 5(1)  -> (空闲帧)
1(1) 4(1) 5(1) 6(1)  -> (空闲帧)
7(1) 4(1) 5(1) 6(1)  -> 1
7(1) 1(1) 5(1) 6(1)  -> 4
7(1) 1(1) 4(1) 6(1)  -> 5
7(1) 1(1) 4(1) 6(2)
7(1) 1(1) 4(2) 6(2)
7(1) 1(1) 4(2) 6(3)
7(1) 1(1) 4(3) 6(3)
7(1) 1(1) 4(3) 6(4)
7(1) 1(1) 4(3) 2(1)  -> 6
7(1) 1(1) 5(1) 2(1)  -> 4

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 4
缺页次数 = 9
缺页率 = 64.29%
```

**测试组3：局部性引用串**

引用串：1 1 1 2 2 2 3 3 3 1 1 1 内存帧数：2, 3, 4

我们以内存帧数为3的输出结果为例：

```bash
===== FIFO 算法 =====
1
1
1
1 2
1 2
1 2
1 2 3
1 2 3
1 2 3
1 2 3
1 2 3
1 2 3

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== LRU 算法 =====
1
1
1
2 1
2 1
2 1
3 2 1
3 2 1
3 2 1
1 3 2
1 3 2
1 3 2

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== Clock 算法 =====
1(1)  -> 0
1(1)
1(1)
1(1) 2(1)  -> 0
1(1) 2(1)
1(1) 2(1)
1(1) 2(1) 3(1)  -> 0
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(11)
1(11)
1(11) 2(11)  -> (空闲帧)
1(11) 2(11)
1(11) 2(11)
1(11) 2(11) 3(10)  -> (空闲帧)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(2)
1(3)
1(3) 2(1)  -> (空闲帧)
1(3) 2(2)
1(3) 2(3)
1(3) 2(3) 3(1)  -> (空闲帧)
1(3) 2(3) 3(2)
1(3) 2(3) 3(3)
1(4) 2(3) 3(3)
1(5) 2(3) 3(3)
1(6) 2(3) 3(3)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(2)
1(3)
1(3) 2(1)  -> (空闲帧)
1(3) 2(2)
1(3) 2(3)
1(3) 2(3) 3(1)  -> (空闲帧)
1(3) 2(3) 3(2)
1(3) 2(3) 3(3)
1(4) 2(3) 3(3)
1(5) 2(3) 3(3)
1(6) 2(3) 3(3)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%
```



### 2.2 主要发现现象

1. **Belady异常现象**：在FIFO算法中观察到，某些引用串在增加内存帧数时，缺页次数反而增加，违反了直觉预期。
2. **关于局部性原理**：LRU算法在具有良好时间局部性的引用串中表现最佳，对于空间局部性强的程序，所有算法的性能都有明显提升
3. **算法收敛性**：当内存帧数接近或等于引用页面数时，我们发现所有算法的缺页率都趋于相同，而在内存严重不足时（帧数很少），算法间的差异明显。
4. **频率算法存在的现象**：LFU在短期突发访问模式下表现较差，MFU在大多数实际应用场景中性能不佳。

## 3. 帧数与缺页数关系曲线图



### 3.1 曲线图分析

**循环访问场景**：在整体上大部分算法表现趋同，因为访问模式相对规律。其中FIFO算法出现明显的Belady异常现象，LRU和Enhanced Clock算法表现相对稳定，而MFU算法在所有场景中表现最差。

**随机引用场景**：算法间差异较明显，LRU和Enhanced Clock表现最好

**局部性引用场景**：LRU算法优势最明显，很好地利用了时间局部性

## 4. 增强二次机会算法的模拟实现

### 4.1 算法原理

增强二次机会算法（Enhanced Clock Algorithm）是对传统时钟算法的改进，它考虑了页面的访问位（R）和修改位（M），将页面分为四类：

1. **类别1 (R=0, M=0)**：最近未被访问且未被修改，最佳替换候选
2. **类别2 (R=0, M=1)**：最近未被访问但已被修改，需要写回
3. **类别3 (R=1, M=0)**：最近被访问但未被修改
4. **类别4 (R=1, M=1)**：最近被访问且已被修改，最差替换候选

### 4.2 程序实现关键代码分析

```cpp
void Replace::Eclock(void) {
    //初始化代码
    
    for (k = 0; k < PageNumber; k++) {
        int next = ReferencePage[k];
        bool isWrite = ReferenceType[k];
        bool found = false;
        
        // 检查页面是否已在内存中
        for (int i = 0; i < FrameNumber; i++) {
            if (EclockFrames[i].pageNum == next) {
                EclockFrames[i].R = true; 
                if (isWrite) EclockFrames[i].M = true; 
                found = true;
                break;
            }
        }
        
        if (found) continue; 
        
        // 缺页处理
        FaultNumber++;
        int victim = -1;
        
        // 寻找 (R=0, M=0)
        int startPointer = currentPointer;
        do {
            if (EclockFrames[currentPointer].pageNum == -1) {
                victim = currentPointer; 
                break;
            }
            else if (EclockFrames[currentPointer].R == 0 && 
                     EclockFrames[currentPointer].M == 0) {
                victim = currentPointer; 
                break;
            }
            currentPointer = (currentPointer + 1) % FrameNumber;
        } while (currentPointer != startPointer && victim == -1);
        
        // 寻找 (R=0, M=1)
        if (victim == -1) {
            startPointer = currentPointer;
            do {
                if (EclockFrames[currentPointer].R == 0 && 
                    EclockFrames[currentPointer].M == 1) {
                    victim = currentPointer; 
                }
                EclockFrames[currentPointer].R = 0; 
                currentPointer = (currentPointer + 1) % FrameNumber;
            } while (currentPointer != startPointer && victim == -1);
        }

    }
}
```

### 4.3 算法特点

1. **优先级替换**：按照四个类别的优先级顺序寻找替换页面
2. **减少磁盘I/O**：优先替换未修改的页面，减少写回操作
3. **二次机会机制**：给予被访问页面第二次机会，清除R位后继续保留
4. **循环扫描**：使用时钟指针循环扫描，保证公平性

## 5. 各算法适用场景综合分析

### 5.1 算法特性对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优缺点 |
|------|------------|------------|----------|--------|
| FIFO | O(n) | O(1) | 访问模式随机，内存充足 | 简单易实现，但可能出现Belady异常 |
| LRU | O(n) | O(n) | 具有时间局部性的程序 | 性能优秀，但实现复杂度高 |
| Clock | O(n) | O(1) | 一般应用场景 | LRU的良好近似，实现简单 |
| Enhanced Clock | O(n) | O(1) | 有读写区分的应用 | 考虑页面修改状态，减少I/O |
| LFU | O(n) | O(n) | 长期运行的稳定程序 | 适合访问频率稳定的场景 |
| MFU | O(n) | O(n) | 特殊的访问模式 | 一般应用中性能较差 |

### 5.2 内存帧数适应性分析

**内存严重不足时（帧数 < 页面数/3）**：
- LRU和Enhanced Clock算法优势明显
- FIFO算法表现不稳定，容易出现异常
- 频率算法由于统计信息不足，表现一般

**内存适中时（帧数 = 页面数/3 ~ 页面数/2）**：
- 所有算法性能差距缩小
- Enhanced Clock和LRU仍保持轻微优势
- 选择算法时应考虑实现复杂度

**内存充足时（帧数 > 页面数/2）**：
- 所有算法性能趋于相同
- 应优先选择实现简单的算法（如FIFO、Clock）
- 过度优化反而增加系统开销

### 5.3 引用串模式适应性

**顺序访问模式**：
- LRU表现最佳，很好利用了时间局部性
- FIFO容易出现异常，需要谨慎使用
- Enhanced Clock是较好的折中选择

**随机访问模式**：
- 各算法差异不大
- 应选择实现简单、开销小的算法
- Clock算法是较好选择

**循环访问模式**：
- 当循环长度小于帧数时，所有算法表现相似
- 当循环长度大于帧数时，LRU优势明显
- MFU在所有情况下都表现较差

**局部性访问模式**：
- LRU算法表现最优
- Enhanced Clock紧随其后
- 频率算法在长期稳定后表现良好

## 6. 实验总结与结论

### 6.1 主要发现

1. **没有万能算法**：不同的页面访问模式下，各算法的性能表现差异显著，需要根据具体应用场景选择合适的算法。

2. **局部性原理的重要性**：具有良好时间和空间局部性的程序，大多数置换算法都能取得较好的效果，其中LRU算法表现最为稳定。

3. **内存大小的影响**：内存帧数对算法性能的影响呈非线性关系，存在拐点效应。在内存严重不足时，算法选择最为关键。

4. **实现复杂度与性能的权衡**：Enhanced Clock算法在保持相对简单实现的同时，能够接近LRU算法的性能，是实际系统中的良好选择。

### 6.2 实际应用建议

1. **系统设计阶段**：应该根据预期的工作负载特性选择合适的页面置换算法，而不是盲目追求理论上的最优算法。

2. **动态调整策略**：在实际系统中，可以考虑根据运行时的访问模式动态调整页面置换策略。

3. **混合算法**：对于复杂的应用场景，可以考虑将多种算法结合，对不同类型的页面采用不同的置换策略。

### 6.3 实验局限性

1. **模拟环境简化**：实验中的引用串相对简单，实际应用中的访问模式更加复杂