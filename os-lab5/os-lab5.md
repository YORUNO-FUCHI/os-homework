# 页面置换算法模拟实验报告

## 1. 实验目的与内容

本实验通过编程实现了六种经典的页面置换算法：FIFO（先进先出）、LRU（最近最少使用）、Clock（时钟算法）、Enhanced Clock（增强二次机会算法）、LFU（最少使用频率）和MFU（最多使用频率）算法，通过模拟不同的页面引用串和内存帧数配置，分析各算法的性能特点。

## 2. 不同引用串与内存帧的测试现象

### 2.1 测试配置

在实验中，我们进行了以下几组典型测试：

**测试组1：循环引用串**

引用串：1 2 3 4 1 2 3 4 1 2 内存帧数：2, 3, 4, 5

我们以内存帧数为4的输出结果为例：

```bash
===== FIFO 算法 =====
1
1 2
1 2 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== LRU 算法 =====
1
2 1
3 2 1
4 3 2 1
1 4 3 2
2 1 4 3
3 2 1 4
4 3 2 1
1 4 3 2
2 1 4 3

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== Clock 算法 =====
1(1)  -> 0
1(1) 2(1)  -> 0
1(1) 2(1) 3(1)  -> 0
1(1) 2(1) 3(1) 4(1)  -> 0
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)
1(1) 2(1) 3(1) 4(1)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(10) 2(11)  -> (空闲帧)
1(10) 2(11) 3(10)  -> (空闲帧)
1(10) 2(11) 3(10) 4(11)  -> (空闲帧)
1(11) 2(11) 3(10) 4(11)
1(11) 2(11) 3(10) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)
1(11) 2(11) 3(11) 4(11)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 2(1)  -> (空闲帧)
1(1) 2(1) 3(1)  -> (空闲帧)
1(1) 2(1) 3(1) 4(1)  -> (空闲帧)
1(2) 2(1) 3(1) 4(1)
1(2) 2(2) 3(1) 4(1)
1(2) 2(2) 3(2) 4(1)
1(2) 2(2) 3(2) 4(2)
1(3) 2(2) 3(2) 4(2)
1(3) 2(3) 3(2) 4(2)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 2(1)  -> (空闲帧)
1(1) 2(1) 3(1)  -> (空闲帧)
1(1) 2(1) 3(1) 4(1)  -> (空闲帧)
1(2) 2(1) 3(1) 4(1)
1(2) 2(2) 3(1) 4(1)
1(2) 2(2) 3(2) 4(1)
1(2) 2(2) 3(2) 4(2)
1(3) 2(2) 3(2) 4(2)
1(3) 2(3) 3(2) 4(2)

淘汰页面序列:
缺页次数 = 4
缺页率 = 40.00%
```

**测试组2：随机引用串**

引用串：1r 4r 5r 6r 7w 1r 4r 6r 4r 6r 4r 6r 2r 5r 内存帧数：2, 3, 4, 5

我们以内存帧数为4的输出结果为例：

```bash
===== FIFO 算法 =====
1
1 4
1 4 5
1 4 5 6
7 4 5 6  -> 1
7 1 5 6  -> 4
7 1 4 6  -> 5
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 6
7 1 4 2  -> 6
5 1 4 2  -> 7

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 7
缺页次数 = 9
缺页率 = 64.29%

===== LRU 算法 =====
1
4 1
5 4 1
6 5 4 1
7 6 5 4  -> 1
1 7 6 5  -> 4
4 1 7 6  -> 5
6 4 1 7
4 6 1 7
6 4 1 7
4 6 1 7
6 4 1 7
2 6 4 1  -> 7
5 2 6 4  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 7 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== Clock 算法 =====
1(1)  -> 0
1(1) 4(1)  -> 0
1(1) 4(1) 5(1)  -> 0
1(1) 4(1) 5(1) 6(1)  -> 0
7(1) 4(0) 5(0) 6(0)  -> 1
7(1) 1(1) 5(0) 6(0)  -> 4
7(1) 1(1) 4(1) 6(0)  -> 5
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(1) 1(1) 4(1) 6(1)
7(0) 1(0) 4(0) 2(1)  -> 6
5(1) 1(0) 4(0) 2(1)  -> 7

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 7
缺页次数 = 9
缺页率 = 64.29%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(10) 4(10)  -> (空闲帧)
1(10) 4(10) 5(10)  -> (空闲帧)
1(10) 4(10) 5(10) 6(10)  -> (空闲帧)
7(11) 4(00) 5(00) 6(00)  -> 1
7(11) 1(10) 5(00) 6(00)  -> 4
7(11) 1(10) 4(10) 6(00)  -> 5
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(11) 1(10) 4(10) 6(10)
7(01) 1(00) 4(00) 2(10)  -> 6
7(01) 5(10) 4(00) 2(10)  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 4(1)  -> (空闲帧)
1(1) 4(1) 5(1)  -> (空闲帧)
1(1) 4(1) 5(1) 6(1)  -> (空闲帧)
7(1) 4(1) 5(1) 6(1)  -> 1
7(1) 1(1) 5(1) 6(1)  -> 4
7(1) 1(1) 4(1) 6(1)  -> 5
7(1) 1(1) 4(1) 6(2)
7(1) 1(1) 4(2) 6(2)
7(1) 1(1) 4(2) 6(3)
7(1) 1(1) 4(3) 6(3)
7(1) 1(1) 4(3) 6(4)
2(1) 1(1) 4(3) 6(4)  -> 7
2(1) 5(1) 4(3) 6(4)  -> 1

淘汰页面序列: 1 -> 4 -> 5 -> 7 -> 1
缺页次数 = 9
缺页率 = 64.29%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(1) 4(1)  -> (空闲帧)
1(1) 4(1) 5(1)  -> (空闲帧)
1(1) 4(1) 5(1) 6(1)  -> (空闲帧)
7(1) 4(1) 5(1) 6(1)  -> 1
7(1) 1(1) 5(1) 6(1)  -> 4
7(1) 1(1) 4(1) 6(1)  -> 5
7(1) 1(1) 4(1) 6(2)
7(1) 1(1) 4(2) 6(2)
7(1) 1(1) 4(2) 6(3)
7(1) 1(1) 4(3) 6(3)
7(1) 1(1) 4(3) 6(4)
7(1) 1(1) 4(3) 2(1)  -> 6
7(1) 1(1) 5(1) 2(1)  -> 4

淘汰页面序列: 1 -> 4 -> 5 -> 6 -> 4
缺页次数 = 9
缺页率 = 64.29%
```

**测试组3：局部性引用串**

引用串：1 1 1 2 2 2 3 3 3 1 1 1 内存帧数：2, 3, 4

我们以内存帧数为3的输出结果为例：

```bash
===== FIFO 算法 =====
1
1
1
1 2
1 2
1 2
1 2 3
1 2 3
1 2 3
1 2 3
1 2 3
1 2 3

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== LRU 算法 =====
1
1
1
2 1
2 1
2 1
3 2 1
3 2 1
3 2 1
1 3 2
1 3 2
1 3 2

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== Clock 算法 =====
1(1)  -> 0
1(1)
1(1)
1(1) 2(1)  -> 0
1(1) 2(1)
1(1) 2(1)
1(1) 2(1) 3(1)  -> 0
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)
1(1) 2(1) 3(1)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== Enhanced Clock 算法 =====
1(10)  -> (空闲帧)
1(11)
1(11)
1(11) 2(11)  -> (空闲帧)
1(11) 2(11)
1(11) 2(11)
1(11) 2(11) 3(10)  -> (空闲帧)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)
1(11) 2(11) 3(11)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== LFU (最不经常使用) 算法 =====
1(1)  -> (空闲帧)
1(2)
1(3)
1(3) 2(1)  -> (空闲帧)
1(3) 2(2)
1(3) 2(3)
1(3) 2(3) 3(1)  -> (空闲帧)
1(3) 2(3) 3(2)
1(3) 2(3) 3(3)
1(4) 2(3) 3(3)
1(5) 2(3) 3(3)
1(6) 2(3) 3(3)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%

===== MFU (最经常使用) 算法 =====
1(1)  -> (空闲帧)
1(2)
1(3)
1(3) 2(1)  -> (空闲帧)
1(3) 2(2)
1(3) 2(3)
1(3) 2(3) 3(1)  -> (空闲帧)
1(3) 2(3) 3(2)
1(3) 2(3) 3(3)
1(4) 2(3) 3(3)
1(5) 2(3) 3(3)
1(6) 2(3) 3(3)

淘汰页面序列:
缺页次数 = 3
缺页率 = 25.00%
```



### 2.2 主要发现现象

1. **Belady异常现象**：在FIFO算法中观察到，某些引用串在增加内存帧数时，缺页次数反而增加，违反了直觉预期。
2. **关于局部性原理**：LRU算法在具有良好时间局部性的引用串中表现最佳，对于空间局部性强的程序，所有算法的性能都有明显提升
3. **算法收敛性**：当内存帧数接近或等于引用页面数时，我们发现所有算法的缺页率都趋于相同，导致在输出的情况下几个算法的差别不明显，而在内存严重不足时（帧数很少），算法间的差异明显。
4. **频率算法存在的现象**：LFU在短期突发访问模式下表现较差，MFU在大多数实际应用场景中性能不佳。

## 3. 帧数与缺页数关系曲线图



### 3.1 曲线图分析

**循环访问场景**：在整体上大部分算法表现趋同，因为访问模式相对规律。其中FIFO算法出现明显的Belady异常现象，LRU和Enhanced Clock算法表现相对稳定，而MFU算法在所有场景中表现最差。

**随机引用场景**：算法间差异较明显，LRU和Enhanced Clock表现最好

**局部性引用场景**：LRU算法优势最明显，很好地利用了时间局部性

## 4. 增强二次机会算法的模拟实现

### 4.1 算法原理

增强二次机会算法（Enhanced Clock Algorithm）是对传统时钟算法的改进，它考虑了页面的访问位（R）和修改位（M），将页面分为四类：

1. **类别1 (R=0, M=0)**：最近未被访问且未被修改，最佳替换候选
2. **类别2 (R=0, M=1)**：最近未被访问但已被修改，需要写回
3. **类别3 (R=1, M=0)**：最近被访问但未被修改
4. **类别4 (R=1, M=1)**：最近被访问且已被修改，最差替换候选

### 4.2 程序实现关键代码分析

```cpp
void Replace::Eclock(void) {
    //初始化代码
    
    for (k = 0; k < PageNumber; k++) {
        int next = ReferencePage[k];
        bool isWrite = ReferenceType[k];
        bool found = false;
        
        // 检查页面是否已在内存中
        for (int i = 0; i < FrameNumber; i++) {
            if (EclockFrames[i].pageNum == next) {
                EclockFrames[i].R = true; 
                if (isWrite) EclockFrames[i].M = true; 
                found = true;
                break;
            }
        }
        
        if (found) continue; 
        
        // 缺页处理
        FaultNumber++;
        int victim = -1;
        
        // 寻找 (R=0, M=0)
        int startPointer = currentPointer;
        do {
            if (EclockFrames[currentPointer].pageNum == -1) {
                victim = currentPointer; 
                break;
            }
            else if (EclockFrames[currentPointer].R == 0 && 
                     EclockFrames[currentPointer].M == 0) {
                victim = currentPointer; 
                break;
            }
            currentPointer = (currentPointer + 1) % FrameNumber;
        } while (currentPointer != startPointer && victim == -1);
        
        // 寻找 (R=0, M=1)
        if (victim == -1) {
            startPointer = currentPointer;
            do {
                if (EclockFrames[currentPointer].R == 0 && 
                    EclockFrames[currentPointer].M == 1) {
                    victim = currentPointer; 
                }
                EclockFrames[currentPointer].R = 0; 
                currentPointer = (currentPointer + 1) % FrameNumber;
            } while (currentPointer != startPointer && victim == -1);
        }

    }
}
```

### 4.3 算法特点

该算法通过双重扫描，优先选择未访问且未修改的页面，减少I/O开销，其次选择未访问但已修改的页面；之后在第二轮扫描中清除访问位，为下次扫描做准备，同时确保活跃页面不会被过早替换。

首先从当前指针位置开始，顺时针扫描页面帧，寻找(R=0, M=0)的理想页面；如果找到空闲帧（pageNum == -1），直接使用；如果找到符合条件的页面，立即选择为牺牲页；扫描一圈后如果没找到，进入第二轮。

在第二轮中，先从当前指针位置开始扫描，寻找(R=0, M=1)的页面，并在扫描过程中，将所有经过页面的R位清零，最终找到符合条件的页面后选择为牺牲页。

## 5. 各算法适用场景

### 5.1 算法特性对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 | 优缺点 |
|------|------------|------------|----------|--------|
| FIFO | O(n) | O(1) | 访问模式随机，内存充足 | 简单易实现，但可能出现Belady异常 |
| LRU | O(n) | O(n) | 具有时间局部性的程序 | 性能优秀，但实现复杂度高 |
| Clock | O(n) | O(1) | 一般应用场景 | LRU的良好近似，实现简单 |
| Enhanced Clock | O(n) | O(1) | 有读写区分的应用 | 考虑页面修改状态，减少I/O |
| LFU | O(n) | O(n) | 长期运行的稳定程序 | 适合访问频率稳定的场景 |
| MFU | O(n) | O(n) | 特殊的访问模式 | 一般应用中性能较差 |

### 5.2 内存帧数适应性

**1.内存严重不足时（帧数 < 页面数/3）**：

LRU和Enhanced Clock算法优势明显，而FIFO算法表现不稳定，容易出现异常，频率算法由于统计信息不足，表现一般。

**2.内存适中时（帧数 = 页面数/3 ~ 页面数/2）**：

在该情况下所有算法性能差距缩小，其中Enhanced Clock和LRU仍保持轻微优势

**3.内存充足时（帧数 > 页面数/2）**：

此时所有算法性能趋于相同，该情况下应优先选择实现简单的算法（如FIFO、Clock）

### 5.3 引用串模式适应性

**1.随机访问模式**：

该模式下各算法差异不大，但是仍应选择实现简单、开销小的算法，其中Clock算法是较好选择

**2.循环访问模式**：

当循环长度小于帧数时，所有算法表现相似，而当循环长度大于帧数时，LRU优势明显。MFU在所有情况下都表现较差。

**3.局部性访问模式**：

此时LRU算法表现最优，Enhanced Clock次之，频率算法在长期稳定后表现良好。

## 6. 实验总结与结论

不同的页面访问模式下，各算法的性能表现差异显著，需要根据具体应用场景选择合适的算法。如随机访问模式下各算法差别不大，局部性访问模式下LRU最优；而在帧数与页面数相对数量不同时，算法之间也有差别。

时空局部性对于算法有着显著的影响；在具有良好时间和空间局部性的程序，大多数都能取得较好的效果，其中LRU算法表现最为稳定。内存帧数对算法有着非线性的影响：在内存严重不足时，算法选择最为关键。

经过对Enhanced Clock算法的学习，发现在保持相对简单实现的同时，它能够接近LRU算法的性能，是实际系统中的良好选择。

