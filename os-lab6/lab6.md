# 磁盘调度算法实验报告

## 实验概述

本实验实现并比较了五种经典的磁盘调度算法：FCFS（先来先服务）、SSTF（最短寻道时间优先）、SCAN（扫描算法）、C-SCAN（循环扫描算法）和LOOK算法。通过模拟磁盘臂的移动过程，分析不同算法在寻道距离、方向改变次数等性能指标上的表现。

## 1. 各个算法的代码实现方案（详细解释）

为了方便进行解释，实验参数设置如下：

当前磁头位置：50号磁道；初始移动方向：向高磁道号方向（1）；磁盘范围：0-199号磁道;随机生成的请求序列：132, 10, 141, 171, 187, 135, 43, 187

### 1.1 FCFS（First Come First Serve）算法

**实现原理：**
FCFS算法严格按照请求到达的先后顺序处理磁盘访问请求，不考虑任何优化策略。

**算法特点：**

该算法的优点在于简单直接，对所有的请求相对而言公平，且无饥饿现象；

但是平均寻道时间长、频繁的方向切换增加开销，且无法利用磁盘访问局部性。

### 1.2 SSTF（Shortest Seek Time First）算法

**实现原理：**
SSTF算法总是选择距离当前磁头位置最近的请求进行处理，采用贪心策略最小化每次移动的寻道时间。

**实现特点：**

该算法使用visited数组标记已处理的请求，避免重复处理

其优点在于每次遍历所有未处理请求，选择距离最小的，使得总寻道距离最小；

但是可能导致某些边缘请求长时间得不到服务（饥饿现象）。

### 1.3 SCAN（电梯算法）算法

**实现原理：**
SCAN算法模拟电梯运行方式，磁头在一个方向上移动，处理路径上的所有请求，直到到达磁盘边界后改变方向。

**代码解释：**

```c++
void DiskArm::SCAN(){
    int totalRequests = RequestNumber + 2;
    int *allCylinders = new int[totalRequests];
    
    // 将请求和边界值合并排序
    for (int i = 0; i < RequestNumber; i++) {
        allCylinders[i] = Cylinder[i];
    }
    allCylinders[RequestNumber] = MinCylinder;
    allCylinders[RequestNumber + 1] = MaxCylinder;
    
    std::sort(allCylinders, allCylinders + totalRequests);
    
    // 根据初始方向选择处理顺序
    if (Direction == 1) {
        // 先处理当前位置到高端的请求
        // 到达边界后改变方向处理低端请求
    } else {
        // 先处理当前位置到低端的请求
        // 到达边界后改变方向处理高端请求
    }
}
```

该代码始终保持单向移动直到边界，且仅在边界处改变方向；在边界点不打印。

**实现特点：**

该算法将所有请求和磁盘边界值统一排序

其优点在于可以保证无饥饿现象，方向切换次数最少（仅1次），还有着较高吞吐量（适合重负载）

但是平均响应时间不如LOOK算法。

### 1.4 C-SCAN（循环扫描）算法

**实现原理：**
C-SCAN算法是SCAN的改进版，磁头到达一端后立即跳转到另一端继续单向扫描，避免了往返扫描可能造成的不公平现象。

**代码解释：**

```cpp
void DiskArm::CSCAN(){
    int *sortedRequests = new int[RequestNumber];
    // 对请求进行排序
    
    if (Direction == 1) {
        // 处理当前位置到高端的请求
        for (int i = currentPos; i < RequestNumber; i++) {
            // 处理请求
        }
        
        // 跳转到磁盘开始位置
        if (currentPos > 0) {
            SeekNumber += abs(Current - MaxCylinder);
            SeekNumber += abs(MaxCylinder - MinCylinder);
            Current = MinCylinder;
            
            // 处理低端剩余请求
            for (int i = 0; i < currentPos; i++) {
                // 处理请求
            }
        }
    }
}
```

**实现特点：**
- 单向扫描模式，提供更公平的服务
- 跳转时需要计算边界到边界的移动距离
- 减少了等待时间的方差
- 适合处理大量随机分布的请求

### 1.5 LOOK算法

**实现原理：**
LOOK算法是SCAN算法的优化版本，磁头不必移动到磁盘边界，而是移动到最远的请求位置后就改变方向。

**核心实现：**
```cpp
void DiskArm::LOOK(){
    int *sortedRequests = new int[RequestNumber];
    // 排序所有请求
    
    if (Direction == 1) {
        // 处理当前位置向高端的所有请求
        for (int i = currentPos; i < RequestNumber; i++) {
            // 到达最高请求后直接改变方向
        }
        
        // 改变方向处理剩余请求
        if (currentPos > 0) {
            SeekChange++;
            for (int i = currentPos - 1; i >= 0; i--) {
                // 处理低端请求
            }
        }
    }
}
```

**实现特点：**
- 避免了不必要的边界移动
- 在最后一个请求处改变方向，更加高效
- 结合了SCAN的公平性和效率优势
- 是SCAN算法的实用改进版本

## 2. 根据输出结果分析各个算法的效果和性能

### 2.1 性能数据汇总

| 算法 | 总寻道距离 | 方向改变次数 | 平均寻道距离 | 性能排名 |
|------|------------|--------------|--------------|----------|
| FCFS | 669 | 4 | 83.62 | 5 |
| SSTF | 217 | 2 | 27.12 | 1 |
| SCAN | 338 | 1 | 42.25 | 3 |
| C-SCAN | 391 | 1 | 48.88 | 4 |
| LOOK | 314 | 1 | 39.25 | 2 |

### 2.2 详细性能分析

**FCFS算法分析：**
- **执行序列：** 50→132→10→141→171→187→135→43→187
- **主要问题：** 磁头频繁来回移动，从132跳到10，再从187跳到135，造成大量不必要的寻道
- **方向改变：** 4次方向改变，最多，说明磁头移动极不规律
- **适用场景：** 仅适合请求量很小或对公平性要求极高的场景

**SSTF算法分析：**
- **执行序列：** 50→43→10→132→135→141→171→187→187
- **优势明显：** 总寻道距离最短（217），平均寻道距离最小（27.12）
- **策略有效：** 贪心选择最近请求，显著减少了磁头移动距离
- **潜在问题：** 虽然本次测试中表现最优，但可能导致边缘请求饥饿

**SCAN算法分析：**
- **执行序列：** 50→132→135→141→171→187→187→43→10
- **移动规律：** 先向高磁道号移动到边界，再反向处理剩余请求
- **平衡性能：** 寻道距离适中（338），方向改变次数少（1次）
- **稳定特性：** 提供相对公平和可预测的服务时间

**C-SCAN算法分析：**
- **执行序列：** 50→132→135→141→171→187→187→0→10→43
- **循环特性：** 单向扫描后跳转到磁盘开始位置
- **额外开销：** 跳转产生的移动距离（199+10=209）占总距离的53%
- **公平性：** 提供更均匀的服务，但效率有所下降

**LOOK算法分析：**
- **执行序列：** 50→132→135→141→171→187→187→43→10
- **优化效果：** 相比SCAN减少了不必要的边界移动
- **效率提升：** 寻道距离（314）比SCAN（338）减少7%
- **最佳平衡：** 在公平性和效率之间达到良好平衡

### 2.3 算法特性对比

**寻道效率排序：** SSTF > LOOK > SCAN > C-SCAN > FCFS

**公平性排序：** C-SCAN > SCAN ≈ LOOK > SSTF > FCFS

**稳定性排序：** SCAN ≈ C-SCAN ≈ LOOK > FCFS > SSTF

## 3. 各个算法功能的综合比较

**高效率优先场景（如SSD、高速存储）：**
- 首选：SSTF算法
- 备选：LOOK算法

**公平性优先场景（如多用户系统）：**
- 首选：C-SCAN算法
- 备选：SCAN算法

**平衡性能场景（如通用操作系统）：**
- 首选：LOOK算法
- 备选：SCAN算法

**简单实现场景（如嵌入式系统）：**
- 首选：FCFS算法
- 备选：SSTF算法

## 4. 实验结论

通过本次实验，我们深入理解了不同磁盘调度算法的工作原理和性能特征：

1. **SSTF算法**在寻道效率方面表现最优，但存在公平性问题
2. **LOOK算法**提供了效率和公平性的最佳平衡，是实际系统的理想选择
3. **SCAN系列算法**保证了良好的公平性，适合对响应时间一致性要求高的场景
4. **FCFS算法**虽然效率最低，但在特定场景下仍有其价值



